import { db } from "../server/db";
import {
  products,
  dataComponents,
  detectionStrategies,
  analytics,
  mitreAssets,
  techniques,
  productAliases
} from "../shared/schema";

// Import MITRE data (auto-generated by extract_mitre_data.py or manually curated)
import {
  dataComponents as dcData,
  detectionStrategies as dsData,
  mitreAssets as maData,
  techniques as tData,
} from "../client/src/lib/mitreData";

// Import product catalog (maintained separately, not auto-generated)
import { ctidProducts } from "../client/src/lib/products";

async function seedDatabase() {
  console.log("[*] Starting database seed...");

  try {
    // Note: Tactics are stored within techniques in the current data model
    // The STIX knowledge graph handles tactics separately via the server-side loader
    console.log("[*] Skipping Tactics seed (handled by STIX knowledge graph)...");

    // Seed MITRE Assets (from Record to array)
    console.log("[*] Seeding MITRE Assets...");
    const assetArray = Object.values(maData);
    const assetData = assetArray.map(asset => ({
      assetId: asset.id,
      name: asset.name,
      domain: asset.domain,
      description: asset.description,
    }));
    if (assetData.length > 0) {
      await db.insert(mitreAssets).values(assetData).onConflictDoNothing();
      console.log(`[✓] Seeded ${assetData.length} MITRE assets`);
    } else {
      console.log(`[!] No assets to seed (0 items)`);
    }

    // Seed Data Components (from Record to array)
    console.log("[*] Seeding Data Components...");
    const dcArray = Object.values(dcData);
    const dcDataValues = dcArray.map(dc => ({
      componentId: dc.id,
      name: dc.name,
      dataSourceName: dc.dataSource,
      description: dc.description,
    }));
    if (dcDataValues.length > 0) {
      await db.insert(dataComponents).values(dcDataValues).onConflictDoNothing();
      console.log(`[✓] Seeded ${dcDataValues.length} data components`);
    } else {
      console.log(`[!] No data components to seed (0 items)`);
    }

    // Seed Detection Strategies
    console.log("[*] Seeding Detection Strategies...");
    const dsDataValues = dsData.map(ds => ({
      strategyId: ds.id,
      name: ds.name,
      description: ds.description,
    }));
    if (dsDataValues.length > 0) {
      await db.insert(detectionStrategies).values(dsDataValues).onConflictDoNothing();
      console.log(`[✓] Seeded ${dsDataValues.length} detection strategies`);
    } else {
      console.log(`[!] No detection strategies to seed (0 items)`);
    }

    // Seed Analytics
    console.log("[*] Seeding Analytics...");
    const analyticsData = dsData.flatMap(strategy =>
      strategy.analytics.map(analytic => ({
        analyticId: analytic.id,
        strategyId: strategy.id,
        name: analytic.name,
        description: analytic.description,
        pseudocode: analytic.pseudocode,
        dataComponentIds: analytic.dataComponents,
      }))
    );

    if (analyticsData.length > 0) {
      const chunkSize = 500;
      for (let i = 0; i < analyticsData.length; i += chunkSize) {
        const chunk = analyticsData.slice(i, i + chunkSize);
        await db.insert(analytics).values(chunk).onConflictDoNothing();
      }
      console.log(`[✓] Seeded ${analyticsData.length} analytics`);
    } else {
      console.log(`[!] No analytics to seed (0 items)`);
    }

    // Seed Techniques (using correct property names from Technique interface)
    console.log("[*] Seeding MITRE Techniques...");
    const techData = tData.map(technique => ({
      techniqueId: technique.id,
      name: technique.name,
      description: technique.description,
      // Note: Current Technique interface has 'tactic' (singular), 'detectionStrategies' (not detectionStrategyIds)
      // We map these to the DB schema
      isSubtechnique: technique.id.includes('.'), // Infer from ID (e.g., T1059.001)
      tactics: [technique.tactic], // Convert singular to array
      platforms: [], // Not in current data, will be populated by STIX loader
      detectionStrategyIds: technique.detectionStrategies || [],
    }));

    if (techData.length > 0) {
        const chunkSize = 500;
        for (let i = 0; i < techData.length; i += chunkSize) {
            const chunk = techData.slice(i, i + chunkSize);
            await db.insert(techniques).values(chunk).onConflictDoNothing();
        }
        console.log(`[✓] Seeded ${techData.length} MITRE techniques`);
    } else {
      console.log(`[!] No techniques to seed (0 items)`);
    }

    // Seed Products (from ctidProducts)
    console.log("[*] Seeding Products...");
    if (ctidProducts && ctidProducts.length > 0) {
      const productsData = ctidProducts.map(product => ({
        productId: product.id,
        vendor: product.vendor,
        productName: product.productName,
        deployment: product.deployment,
        description: product.description,
        platforms: product.platforms,
        dataComponentIds: product.dataComponentIds,
        mitreAssetIds: product.mitreAssetIds || [],
        source: product.source,
      }));

      await db.insert(products).values(productsData).onConflictDoNothing();
      console.log(`[✓] Seeded ${productsData.length} products`);
    } else {
      console.log(`[!] No products to seed (ctidProducts is empty or stubbed)`);
    }

    // Seed Product Aliases (using FK to products.id)
    console.log("[*] Seeding Product Aliases...");

    // A. Define raw aliases with target product names
    const rawAliases = [
      // Microsoft products
      { targetName: "Microsoft 365 Defender", alias: "m365", confidence: 100 },
      { targetName: "Microsoft 365 Defender", alias: "m365d", confidence: 100 },
      { targetName: "Microsoft 365 Defender", alias: "microsoft defender", confidence: 90 },
      { targetName: "Microsoft 365 Defender", alias: "defender 365", confidence: 90 },
      { targetName: "Microsoft Defender for Endpoint", alias: "mde", confidence: 100 },
      { targetName: "Microsoft Defender for Endpoint", alias: "defender atp", confidence: 90 },
      { targetName: "Microsoft Defender for Endpoint", alias: "mdatp", confidence: 100 },
      { targetName: "Microsoft Sentinel", alias: "azure sentinel", confidence: 100 },
      { targetName: "Microsoft Sentinel", alias: "sentinel", confidence: 90 },
      { targetName: "Azure Active Directory", alias: "aad", confidence: 100 },
      { targetName: "Azure Active Directory", alias: "azure ad", confidence: 100 },
      { targetName: "Azure Active Directory", alias: "entra id", confidence: 100 },
      // CrowdStrike
      { targetName: "CrowdStrike Falcon", alias: "crowdstrike", confidence: 90 },
      { targetName: "CrowdStrike Falcon", alias: "falcon", confidence: 80 },
      { targetName: "CrowdStrike Falcon", alias: "cs falcon", confidence: 100 },
      // SentinelOne
      { targetName: "SentinelOne Singularity", alias: "sentinelone", confidence: 100 },
      { targetName: "SentinelOne Singularity", alias: "s1", confidence: 100 },
      // Palo Alto
      { targetName: "Cortex XDR", alias: "cortex", confidence: 80 },
      { targetName: "Cortex XDR", alias: "palo alto xdr", confidence: 100 },
      // Carbon Black
      { targetName: "Carbon Black Cloud", alias: "cb cloud", confidence: 100 },
      { targetName: "Carbon Black Cloud", alias: "vmware carbon black", confidence: 100 },
      // Elastic
      { targetName: "Elastic Security", alias: "elasticsearch security", confidence: 90 },
      { targetName: "Elastic Security", alias: "elastic siem", confidence: 90 },
      // Splunk
      { targetName: "Splunk Enterprise Security", alias: "splunk es", confidence: 100 },
      { targetName: "Splunk Enterprise Security", alias: "splunk siem", confidence: 90 },
      // AWS
      { targetName: "AWS Security Hub", alias: "security hub", confidence: 80 },
      { targetName: "AWS GuardDuty", alias: "guardduty", confidence: 100 },
      // Google
      { targetName: "Google Cloud Security Command Center", alias: "scc", confidence: 80 },
      { targetName: "Google Chronicle", alias: "chronicle siem", confidence: 90 },
      // Generic
      { targetName: "Sysmon", alias: "system monitor", confidence: 100 },
      { targetName: "Windows Event Logs", alias: "windows logs", confidence: 90 },
      { targetName: "Windows Event Logs", alias: "event logs", confidence: 80 },
    ];

    // B. Build lookup map (productName -> id) from database
    const allProducts = await db.select().from(products);
    const productMap = new Map(allProducts.map(p => [p.productName, p.id]));

    // C. Resolve aliases to productId FK
    const aliasesToInsert: { productId: number; alias: string; confidence: number }[] = [];

    for (const item of rawAliases) {
      const pId = productMap.get(item.targetName);
      if (pId) {
        aliasesToInsert.push({
          productId: pId,
          alias: item.alias,
          confidence: item.confidence
        });
      } else {
        console.warn(`[!] Warning: No product found for alias target "${item.targetName}". Skipping.`);
      }
    }

    // D. Insert verified aliases
    if (aliasesToInsert.length > 0) {
      await db.insert(productAliases).values(aliasesToInsert).onConflictDoNothing();
      console.log(`[✓] Seeded ${aliasesToInsert.length} product aliases`);
    } else {
      console.log(`[!] No aliases inserted. Check if product names match exactly.`);
    }

    console.log("[✓] Database seed completed successfully!");
  } catch (error) {
    console.error("[✗] Error seeding database:", error);
    throw error;
  }
}

seedDatabase()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
