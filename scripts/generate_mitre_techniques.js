#!/usr/bin/env node
import fs from "fs";
import path from "path";
import https from "https";

const STIX_URL =
  process.env.MITRE_STIX_URL ||
  "https://raw.githubusercontent.com/mitre-attack/attack-stix-data/master/enterprise-attack/enterprise-attack.json";
const OUTPUT_PATH =
  process.env.MITRE_TECHNIQUES_OUT || "client/src/lib/mitreTechniquesFull.ts";

const NORMALIZE_REPLACEMENTS = {
  "\u2013": "-",
  "\u2014": "-",
  "\u2018": "'",
  "\u2019": "'",
  "\u201C": "\"",
  "\u201D": "\"",
  "\u2026": "...",
  "\u00A0": " ",
};

const KILL_CHAIN_NAMES = new Set(["mitre-attack", "mitre-ics-attack", "mitre-mobile-attack"]);

function normalizeText(value) {
  if (typeof value !== "string") return "";
  let text = value;
  for (const [from, to] of Object.entries(NORMALIZE_REPLACEMENTS)) {
    text = text.split(from).join(to);
  }
  text = text.normalize("NFKD").replace(/[^\x20-\x7E]+/g, "");
  text = text.replace(/\s+/g, " ").trim();
  return text;
}

function formatTacticName(value) {
  if (!value || typeof value !== "string") return "";
  return value
    .split(/[-_]/g)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

function fetchJson(url) {
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        const status = res.statusCode || 0;
        if (status >= 300 && status < 400 && res.headers.location) {
          return resolve(fetchJson(res.headers.location));
        }
        if (status < 200 || status >= 300) {
          return reject(new Error(`Request failed with status ${status}`));
        }
        let data = "";
        res.setEncoding("utf8");
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          try {
            resolve(JSON.parse(data));
          } catch (error) {
            reject(error);
          }
        });
      })
      .on("error", reject);
  });
}

function getExternalId(obj) {
  const refs = Array.isArray(obj.external_references) ? obj.external_references : [];
  for (const ref of refs) {
    if (ref && ref.source_name === "mitre-attack" && typeof ref.external_id === "string") {
      return ref.external_id;
    }
  }
  return null;
}

function buildOutput(techniques) {
  const header = `// This file is auto-generated by scripts/generate_mitre_techniques.js
// Do not edit this file manually.

export interface FullMitreTechnique {
  id: string;
  name: string;
  tactic: string;
  description: string;
}

export const fullMitreTechniques: FullMitreTechnique[] = `;
  return `${header}${JSON.stringify(techniques, null, 2)};\n`;
}

async function main() {
  console.log(`[mitre] Fetching ${STIX_URL}`);
  const bundle = await fetchJson(STIX_URL);
  const objects = Array.isArray(bundle?.objects)
    ? bundle.objects
    : Array.isArray(bundle)
      ? bundle
      : [];

  const tacticMap = new Map();
  const subtechniqueParents = new Map();

  for (const obj of objects) {
    if (!obj || typeof obj !== "object") continue;
    if (obj.type === "x-mitre-tactic" && obj.x_mitre_shortname) {
      tacticMap.set(obj.x_mitre_shortname, normalizeText(obj.name || obj.x_mitre_shortname));
    }
    if (obj.type === "relationship" && obj.relationship_type === "subtechnique-of") {
      if (obj.source_ref && obj.target_ref) {
        subtechniqueParents.set(obj.source_ref, obj.target_ref);
      }
    }
  }

  const techniqueEntries = [];
  const stixToEntry = new Map();

  for (const obj of objects) {
    if (!obj || typeof obj !== "object") continue;
    if (obj.type !== "attack-pattern") continue;

    const externalId = getExternalId(obj);
    if (!externalId) continue;

    const phases = Array.isArray(obj.kill_chain_phases) ? obj.kill_chain_phases : [];
    const tacticNames = phases
      .filter((phase) => phase && KILL_CHAIN_NAMES.has(phase.kill_chain_name))
      .map((phase) => {
        const mapped = tacticMap.get(phase.phase_name);
        return mapped || formatTacticName(phase.phase_name);
      })
      .filter(Boolean);

    const uniqueTactics = Array.from(new Set(tacticNames));
    const entry = {
      id: externalId,
      name: normalizeText(obj.name || ""),
      tactic: uniqueTactics.join(", "),
      description: normalizeText(obj.description || ""),
      stixId: obj.id,
    };

    techniqueEntries.push(entry);
    if (entry.stixId) {
      stixToEntry.set(entry.stixId, entry);
    }
  }

  for (const entry of techniqueEntries) {
    if (entry.tactic) continue;
    const parentStixId = subtechniqueParents.get(entry.stixId);
    if (!parentStixId) continue;
    const parent = stixToEntry.get(parentStixId);
    if (parent?.tactic) {
      entry.tactic = parent.tactic;
    }
  }

  const outputTechniques = techniqueEntries
    .map(({ stixId, ...rest }) => rest)
    .sort((a, b) => a.id.localeCompare(b.id));

  const outputDir = path.dirname(OUTPUT_PATH);
  if (outputDir && !fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_PATH, buildOutput(outputTechniques), "utf8");
  console.log(`[mitre] Wrote ${outputTechniques.length} techniques to ${OUTPUT_PATH}`);
}

main().catch((error) => {
  console.error("[mitre] Failed to generate techniques:", error);
  process.exit(1);
});
